pragma solidity ^0.8.0; 
    Use specific compiler version while deploying to mainnet

contract HelloWorld { }; contract <NameOfContract> same as file name

string public myString = "Hello World!"; 
    [type] [visibility modifier] [identifier] = "data";

## Data types - values and references

    values means the data/varable stores a value eg- boolean stores true or false,
        bool public b = true;

    int stores number like -1,0,1...,
        int public i = -123;
        int = int256 ranges from -2**255 to 2**255 - 1
            int128 ranges from -2**127 to 2**127 - 1 

    uint or unsigned integer means the number should be greater or equal to zero. No negative num for uint's. Use int for negative & 
    positive nums.
        uint public u = 123; 
        uint = uint256 it ranges from 0 to 2**256 - 1 (commonly used)
            uint16 ranges from 0 to 2**16 - 1
            uint8 ranges from 0 to 2**8 - 1   
            uint goes from uint8 to uint256 in steps of 8

    To find max and min value of datatype
        int public minint = type(int).min;
        int public maxint = type(int).max;

    address stores address,
        address public addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;

    bytes32 will be used when we work with cryptographic hash fn in solidity called keccak256.
        bytes32 public b32 = 0x0000000000000000000000000000000000000000000000000000000000000000; // 32 bytes

    Data types of type references don't store a value instead store the reference to where the actual data is stored eg array is a datatype
    of type reference, since it stores a reference of where the actual array elements are stored.

## Functions

input values are passed during compile time
    uint public a = 15;
    uint public b = 25;

    function addTwoNumber() external view returns(uint) {
        uint sum = a + b;
        return sum;
    }

input values are passed during run time
    function addTwoNumber(uint a, uint b) external pure returns(uint) {
        return a + b;
    }
    function subTwoNumber(int a, int b) external pure returns(int) {
        return a - b;
    }
    external means when we deploy the contract we'll be able to call this function
    pure means this is a read-only fn it does not write data to blockchain; So if we
    try to initialize any variables here, it would give error. 

    view is like pure, both are read-only fns, unlike pure fn view fn can read data from state and 
    global variables.

    If we want to modify the value of state variable from inside a function then dont need to add
    view or pure, as they are used only for read-only fns.

## Variables
    There are 3 types of variables in solidity Local, State and Global

## State variables

    uint public myUint = 123;
    State variables are variables that store data to blockchain these are declared inside a contract but outside a function. If a state variable
    is public then we'll have read access to it, and also the contract automatically creates a getter fn with same name as the variable once we
    deploy it.

## Local variables
    function foo() external {
        uint boo = 456;
    }    
    variables declared inside a fn are local variables and they exist inside the fn, only while the fn is executing after that the variable 
    is gone.

    declaring the State variables 
    uint public i; (initial value - 0)
    bool public b; (initial value - false)
    address public myAddress; (initial value - 0x0000...)

    function foo() external{
        // These variables will be gone after fn finishes excecution - Local variables
        uint x = 123;
        bool f =false;
        x += 456;
        f = true;
        
        // These variables value will be updated when the function is called - State variabless
        i = 123;
        b = true;
        myAddress = address(1);
    }

## Global variables 
    Global variables store info such as blockchain txns and the account that store the function

    function globalVars() external view returns(address, uint, uint) {
        
        address sender = msg.sender; (Since this stores address its datatype is address)
            This global variable stores the address that called this fn globalVars()

        uint timestamp = block.timestamp; (datatype of timestamp is uint)
            Stores the timestamp of when this fn was called

        uint blockNum = block.number; (datatype is uint)
            Stores the current block number

        return(sender, timestamp, blockNum);
            This is how to return multiple values from a fn via the return statement
            according to the datatype of these values specify the return type of this fn
    }

## View and Pure Functions

    Both are read-only fns(Since they dont modify the variable or write anything to the blockchain).
    View fn reads data that's from the blockchain (ie from State, global variables, smart contract) 
    whereas pure fn do not read anything from blockchain (it reads the Local variables)

    uint public num; 
    function viewFunc() external view returns(uint) {
        return num;
    }
        Since it reads the "State" variable num, this is a view fn

    function pureFunc() external pure returns(uint) {
        return 1;
    }
        Since it doesn't read any data from the blockchain or smart contract or state variables. 
        Therefore this is a pure fn
    
    function addTwoNum(uint x) external view returns(uint) {
        return num + x; 
    }
        since value of num is read from blockchain, this is a view fn

    function addTwoNum(uint x, uint y) external pure returns(uint) {
        return x + y; 
    }
        since this fn does not read data from state variable, smart contract or blockchain, therefore this is a pure fn

## Counter using solidity

    int public count = 0;
    since uint doesn't support negative values, so if we try decrement first once contract is deployed it gives error. so make count as int.

    function increment() external {
        count += 1;
    }
    function decrement() external {
        count -= 1;
    }
    since these fns modify the value of count it is not a read fn, therefore it has no view or pure 

## Default values
    
    State and local variables in solidity have default values

    bool public b; (false)
    uint public u; (0)
    int public i; (0)
    address public addr; (0x0000000000000000000000000000000000000000)
        zero address, sequence of 40 zero's followed after 0x
    bytes32 public b32; (0x0000000000000000000000000000000000000000000000000000000000000000)
        32 byte hexadecimal representation of 0's, sequence of 64 zero's followed after 0x
    
    mapping, structs, enums, fixed sized array ...

## Constants

    If a State variables value never change then its better to declare it as a constant.
    By declaring a state variable as constant, we can save gas when a function is called that uses
    that state variable.

    contract Constants {
        address public constant MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;
            21442 gas 
        Keyword constant, variable name in all caps as its a coding convention

        uint public constant MY_UINT = 123;
            21371 gas
    }

    contract Var {
        address public MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; 
            23575 gas
        uint public MY_UINT = 123;
            23471 gas
    }

## If Else

    function num(uint _x) external pure returns(uint){
        if (_x ==1 ) {
            return 1;
        }
        else if (_x == 2) {
            return 2;
        }
        return 3;  
    }

    function ternary(uint _x) external pure returns(bool){
        return _x % 2 ==0 ? true : false;
    }

## For loops
Bigger the number of iterations in a loop, more the gas costs
    function loops() external pure {
        for(uint i = 0; i < 10; i++) {
            
            <-- code -->
            
            To skip certain iteration of the code use continue\
            if (i == 3) {
                continue;
                continue means continue with the next iteration of for loop ie i = 4's iteration
            }

            <-- more code --> (this part will not be executed when i = 3)
            
            To exit the for loop in-between (we'll finish the loop when i = 5)
            if (i == 5) {
                break;
            }
        }
    }

## While loops

    while (condition) {
        // code runs forever until condition becomes false
    }

## For and While loops for sum of n numbers

    function sumFor(uint _n) external pure returns(uint) {
        uint sum;
        for (uint i = 1; i <= _n; i++) {
            sum += i;
        }
        return sum;        
    }

    function sumWhile(uint _n) external pure returns(uint) {
        uint sum;
        while (_n != 0) {
            sum = sum + _n;
            _n--;
        }
        return sum;       
    }

## Error

    when we call a fn in a contract there are 3 ways to throw an error require, revert, assert.
    When an error is thrown inside a transaction the gas is refunded, state variables which are updated, will be reverted.
    In solidity 0.8 we can use custom error to save gas.

## Require
    Require is used to validate input and access control - controlling who gets to call the fn.
        require(cond, "if not print this") - input validation; checks condition, if false throws error msg.


    function require(uint256 _i) public pure {
        require(_i <= 10, "i > 10");
            we require input i to be less than or equal to 10.

        // more code if cond passes       
    }

## Revert 

    function revert(uint256 _i) public pure {
        if (_i > 10) {
            revert("i > 10");
        }
    }

    revert is better option if your condition to check is nested in a lot of if statements
        if (_i > 1) {
            // code
            if(_i > 2) {
                // more code
                if (_i > 10) {
                revert("i > 10"); 
                }
            }
        }

## Assert

    Assert is used to check for conditions that should always be true. If condition evaluates to false then it means there might be
    a bug in the smart contract

    uint256 public num = 123;
    function assert() public view {
        assert(num == 123); // if not then there is a bug in contract
    }

    Now if we call assert() after foo() then assert will no longer be true
    function foo() public {
        // accidently update num
        num = 456;
    }

## Gas refund

    If we send 1000 gas and it used up 100 gas then there will be a gas refund of 900 gas

## State variables reverted
    Any state variables updated before the error was thrown will be undone 

    function foo(uint256 _i) public {
        num += 1;
        require(_i < 10);
    }
    If we pass 13 then the state variable will be updated and since 13 > 10 the check fails; so whatever update was made to the state variable
    will be undone

## Custom errors

    Custom error is cheaper than to use than using require with some error msg - longer the error msg the more gas it uses.
    Right now custom errors can only be used with revert so we need to transform any code with require to revert custom error.
    
    Declaring custom error - error <name of custom error>

    error MyError();
    function customError(uint256 _i) public pure {
        if (_i > 10) {
            revert MyError();
        }
    }

Logging data inside custom error

    error MyError(address caller, uint256 i); - we log the caller of the function and the input that was passed in.  
    function customError(uint256 _i) public view { - since msg.sender is not a local but a global variable so change the function to view type
        if (_i > 10) {
            revert MyError(msg.sender, _i);
        }
    }


## Function modifier - allows to modify code before and / or after function

    modifier <name of fn modifier> {
        // condition
        _; // underscore tells solidity to call the actual fn that this fn modifier wraps. ie execute the rest of the code of the fn. ie call the main fn 
    }
    After this, declare the fn modifier inside the fn signature to which the modifier is to be added.

Basic example 

without modifier
    bool public paused;
    uint256 public count;

    function setPause(bool _paused) external {
        paused = _paused;
    }

    function inc() external {
        require(!paused, "paused");
        count += 1;
    }

    function dec() external {
        require(!paused, "paused");
        count -= 1;
    }

    The functions inc() and dec() can be called only if the condition is met ie the contract is not paused.  
    
    Here the require statement is repeated in multiple functions. So we create a fn modifier for the require statement requiring that the 
    fn can only be called if the contract is not paused.

With modifier

    modifier whenNotPaused() {
        require(!paused, "paused");
        _;
    }

    function inc() external whenNotPaused {
        count += 1;
    }

    function dec() external whenNotPaused {
        count -= 1;
    }

Example of passing inputs to fn modifier

without modifier
    function incBy(uint256 _i) external whenNotPaused { 
        require(_i <= 100, "i >100"); 
        count += _i;
    } - count is incremented by a specific value only if it is less than 100

with modifier
    modifier cap(uint256 _i) {
        require(_i <= 100, "i >100");
        _;
    }

    function incBy(uint256 _i) external whenNotPaused cap(_i) {
        count += _i;
    }

## Sandwich
    fn modifier that sandwiches a fn, means some code will be executed inside the fn modifier, the actual fn will be called and 
    afterwards it will execute more code inside the fn modifier. Also we can add more checks in between these codes.

    modifier sandwich() {
        // code - 1. executes some code
        count += 5;
        _; // calls the main fn
        // more code - executes more code afterwards
        count *= 3;
    }

    function foo() external sandwich {
        count += 1;
    }

    When fn foo is called it first executes the fn modifier sandwich, so it updates count by 5. Then call the main fn which it is attached to
    in this case its foo() so it updates the count by 1 [now count = 6]. After foo() is done executing control is gonna execute more code in the
    fn modifier sandwich, so count is multiplied by 2 [now count = 12].

## Constructor 
    Constructors are special fns that can be called only once when the contract is deployed whereas normal fns can be called multiple times, 
    constructors are mainly used to initialize state variables.
    Parameters are passed during deployment [In remix parameters to constructors are passed via with deploy option]

    address public owner;
    uint public x;

    constructor(uint _x) {
        x = _x; - write code like regular fn
        owner = msg.sender; - initializing the state variable owner to the account that deployed this contract.
                              msg.sender will be the address that deployed this contract
    } 

## Ownable 
    
    Application to claim ownership of the contract

    This contract will have a owner[who deploys this contract], only the owner will be able to set a new owner and there are certain fns only 
    the owner can call.

contract Ownable {
    address public owner; - Declaring global variable owner

    constructor() { - Initializing the owner to the caller who deployed this contract
        owner = msg.sender;
    }

    Creating a Fn modifier for a fn to set a new owner, that can be called only by the owner

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function setOwner(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid address [0x0000...]");
        owner = _newOwner;
    }

    function onlyOwnerCanCall() external onlyOwner {
        // code
    }

    function anyOneCanCall() external {
        // code
    }
}
