pragma solidity ^0.8.0; 
    Use specific compiler version while deploying to mainnet

contract HelloWorld { }; contract <NameOfContract> same as file name

string public myString = "Hello World!"; 
    [type] [visibility modifier] [identifier] = "data";

## Data types  - values and references

    values means the data/varable stores a value eg- boolean stores true or false,
        bool public b = true;

    int stores number like -1,0,1...,
        int public i = -123;
        int = int256 ranges from -2**255 to 2**255 - 1
            int128 ranges from -2**127 to 2**127 - 1 

    uint or unsigned integer means the number should be 
    greater or equal to zero. No negative num for uint's. Use int 
    to use negative numbers and positive
        uint public u = 123; 
        uint = uint256 it ranges from 0 to 2**256 - 1 (commonly used)
            uint16 ranges from 0 to 2**16 - 1
            uint8 ranges from 0 to 2**8 - 1   
            uint goes from uint8 to uint256 in steps of 8

    To find max and min value of datatype
        int public minint = type(int).min;
        int public maxint = type(int).max;

    address stores address,
        address public addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;

    bytes32 will be used when we work with cryptographic hash fn in solidity called keccak256.
        bytes32 public b32 = 0x0000000000000000000000000000000000000000000000000000000000000000; // 32 bytes

    Data types of type references don't store a value instead store the reference to where the 
    actual data is stored eg array is a datatype of type reference, since it stores a reference 
    of where the actual array elements are stored.

## Functions

input values are passed during compile time
    uint public a = 15;
    uint public b = 25;

    function addTwoNumber() public view returns(uint) {
        uint sum = a + b;
        return sum;
    }

input values are passed during run time
    function addTwoNumber(uint a, uint b) external pure returns(uint) {
        return a + b;
    }
    function subTwoNumber(int a, int b) external pure returns(int) {
        return a - b;
    }
    external means when we deploy the contract we'll be able to call this function
    pure means this is a read-only fn it does not write data to blockchain; So if we
    try to initialize any variables here, it would give error. 

    view is like pure, both are read-only fns, unlike pure fn view fn can read data from state and 
    global variables.

    If we want to modify the value of state variable from inside a function then dont need to add
    view or pure, as they are used only for read-only fns.

## Variables
    There are 3 types of variables in solidity Local, State and Global

## State variables

    uint public myUint = 123;
    State variables are variables that store data to blockchain these are declared inside a 
    contract but outside a function. If a state variable is public then we'll have read access to it,
    and also the contract automatically creates a getter fn with same name as the variable.

## Local variables
    function foo() external {
        uint boo = 456;
    }    
    variables declared inside a fn are local variables and they exist 
    inside the fn, only while the fn is executing after that the variable is gone

    declaring the State variables 
    uint public i; (initial value - 0)
    bool public b; (initial value - false)
    address public myAddress; (initial value - 0x0000...)

    function foo() external{
        // These variables will be gone after fn finishes excecution - Local variables
        uint x = 123;
        bool f =false;
        x += 456;
        f = true;
        
        // These variables value will be updated when the function is called - State variabless
        i = 123;
        b = true;
        myAddress = address(1);
    }

## Global variables 
    Global variables store info such as blockchain txns and the account that store the function

    function globalVars() external view returns(address, uint, uint) {
        
        address sender = msg.sender; (Since this stores address its datatype is address)
            This global variable stores the address that called this fn

        uint timestamp = block.timestamp; (datatype of timestamp is uint)
            Stores the timestamp of when this fn was called

        uint blockNum = block.number; (datatype is uint)
            Stores the current block number

        return(sender, timestamp, blockNum);
            This is how to return multiple values from a fn via the return statement
            according to the datatype of these values specify the return type of this fn
    }

## View and Pure Functions

    Both are read-only fns(Since they dont modify the variable or write anything to the blockchain).
    View fn reads data that's from the blockchain (ie from State, global variables, smart contract) 
    whereas pure fn do not read anything from blockchain (it reads the Local variables)

    uint public num; 
    function viewFunc() external view returns(uint) {
        return num;
    }
        Since it reads the "State" variable num, this is a view fn

    function pureFunc() external pure returns(uint) {
        return 1;
    }
        Since it doesn't read any data from the blockchain or smart contract or state variables. 
        Therefore this is a pure fn
    
    function addTwoNum(uint x) external view returns(uint) {
        return num + x; 
    }
        since value of num is read from blockchain, this is a view fn

    function addTwoNum(uint x, uint y) external pure returns(uint) {
        return x + y; 
    }
        since this fn does not read data from state variable, smart contract or blockchain, 
        therefore this is a pure fn

## Counter using solidity

    int public count = 0;
    since uint doesn't support negative values, so if we try decrement first once contract 
    is deployed it gives error. so make count as int.

    function increment() external {
        count += 1;
    }
    function decrement() external {
        count -= 1;
    } 

## Default values
    
    State and local variables in solidity have default values

    bool public b; (false)
    uint public u; (0)
    int public i; (0)
    address public addr; (0x0000000000000000000000000000000000000000)
        zero address, sequence of 40 zero's followed after 0x
    bytes32 public b32; (0x0000000000000000000000000000000000000000000000000000000000000000)
        32 byte hexadecimal representation of 0's, sequence of 64 zero's followed after 0x
    
    mapping, structs, enums, fixed sized array ...

## Constants

    If a State variables value never change then its better to declare it as a constant.
    By declaring a state variable as constant, we can save gas when a function is called that uses
    that state variable.

    contract Constants {
        address public constant MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;
            21442 gas 
        Keyword constant, variable name in all caps as its a coding convention

        uint public constant MY_UINT = 123;
            21371 gas
    }

    contract Var {
        address public MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; 
            23575 gas
        uint public MY_UINT = 123;
            23471 gas
    }

## If Else

    function num(uint _x) external pure returns(uint){
        if (_x ==1 ) {
            return 1;
        }
        else if (_x == 2) {
            return 2;
        }
        return 3;  
    }

    function ternary(uint _x) external pure returns(bool){
        return _x % 2 ==0 ? true : false;
    }

## For loops
Bigger the number of iterations in a loop, more the gas costs
    function loops() external pure {
        for(uint i = 0; i < 10; i++) {
            
            <-- code -->
            
            To skip certain iteration of the code use continue\
            if (i == 3) {
                continue;
                continue means continue with the next iteration of for loop ie i = 4's iteration
            }
            <-- more code --> (this part will not be executed when i = 3)
            
            To exit the for loop in-between (we'll finish the loop when i = 5)
            if (i == 5) {
                break;
            }
        }
    }

## While loops

    while (condition) {
        // code runs forever until condition becomes false
    }

## For and While loops for sum of n numbers

    function sumFor(uint _n) external pure returns(uint) {
        uint sum;
        for (uint i = 1; i <= _n; i++) {
            sum += i;
        }
        return sum;        
    }

    function sumWhile(uint _n) external pure returns(uint) {
        uint sum;
        while (_n != 0) {
            sum = sum + _n;
            _n--;
        }
        return sum;       
    }