pragma solidity ^0.8.0; 
    Use specific compiler version while deploying to mainnet

contract HelloWorld { }; contract <NameOfContract> same as file name

string public myString = "Hello World!"; 
    [type] [visibility modifier] [identifier] = "data";

## Data types - values and references

    values means the data/varable stores a value eg- boolean stores true or false,
        bool public b = true;

    int stores number like -1,0,1...,
        int public i = -123;
        int = int256 ranges from -2**255 to 2**255 - 1
            int128 ranges from -2**127 to 2**127 - 1 

    uint or unsigned integer means the number should be greater or equal to zero. No negative num for uint's. Use int for negative & 
    positive nums.
        uint public u = 123; 
        uint = uint256 it ranges from 0 to 2**256 - 1 (commonly used)
            uint16 ranges from 0 to 2**16 - 1
            uint8 ranges from 0 to 2**8 - 1   
            uint goes from uint8 to uint256 in steps of 8

    To find max and min value of datatype
        int public minint = type(int).min;
        int public maxint = type(int).max;

    address stores address,
        address public addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;

    bytes32 will be used when we work with cryptographic hash fn in solidity called keccak256.
        bytes32 public b32 = 0x0000000000000000000000000000000000000000000000000000000000000000; // 32 bytes

    Data types of type references don't store a value instead store the reference to where the actual data is stored eg array is a datatype
    of type reference, since it stores a reference of where the actual array elements are stored.

## Functions

input values are passed during compile time
    uint public a = 15;
    uint public b = 25;

    function addTwoNumber() external view returns(uint) {
        uint sum = a + b;
        return sum;
    }

input values are passed during run time
    function addTwoNumber(uint a, uint b) external pure returns(uint) {
        return a + b;
    }
    function subTwoNumber(int a, int b) external pure returns(int) {
        return a - b;
    }
    external means when we deploy the contract we'll be able to call this function
    pure means this is a read-only fn it does not write data to blockchain; So if we
    try to initialize any variables here, it would give error. 

    view is like pure, both are read-only fns, unlike pure fn view fn can read data from state and 
    global variables.

    If we want to modify the value of state variable from inside a function then dont need to add
    view or pure, as they are used only for read-only fns.

## Variables
    There are 3 types of variables in solidity Local, State and Global

## State variables

    uint public myUint = 123;
    State variables are variables that store data to blockchain these are declared inside a contract but outside a function. If a state variable
    is public then we'll have read access to it, and also the contract automatically creates a getter fn with same name as the variable once we
    deploy it.

## Local variables
    function foo() external {
        uint boo = 456;
    }    
    variables declared inside a fn are local variables and they exist inside the fn, only while the fn is executing after that the variable 
    is gone.

    declaring the State variables 
    uint public i; (initial value - 0)
    bool public b; (initial value - false)
    address public myAddress; (initial value - 0x0000...)

    function foo() external{
        // These variables will be gone after fn finishes excecution - Local variables
        uint x = 123;
        bool f =false;
        x += 456;
        f = true;
        
        // These variables value will be updated when the function is called - State variabless
        i = 123;
        b = true;
        myAddress = address(1);
    }

## Global variables 
    Global variables store info such as blockchain txns and the account that store the function

    function globalVars() external view returns(address, uint, uint) {
        
        address sender = msg.sender; (Since this stores address its datatype is address)
            This global variable stores the address that called this fn globalVars()

        uint timestamp = block.timestamp; (datatype of timestamp is uint)
            Stores the timestamp of when this fn was called

        uint blockNum = block.number; (datatype is uint)
            Stores the current block number

        return(sender, timestamp, blockNum);
            This is how to return multiple values from a fn via the return statement
            according to the datatype of these values specify the return type of this fn
    }

## View and Pure Functions

    Both are read-only fns(Since they dont modify the variable or write anything to the blockchain).
    View fn reads data that's from the blockchain (ie from State, global variables, smart contract) 
    whereas pure fn do not read anything from blockchain (it reads the Local variables)

    uint public num; 
    function viewFunc() external view returns(uint) {
        return num;
    }
        Since it reads the "State" variable num, this is a view fn

    function pureFunc() external pure returns(uint) {
        return 1;
    }
        Since it doesn't read any data from the blockchain or smart contract or state variables. 
        Therefore this is a pure fn
    
    function addTwoNum(uint x) external view returns(uint) {
        return num + x; 
    }
        since value of num is read from blockchain, this is a view fn

    function addTwoNum(uint x, uint y) external pure returns(uint) {
        return x + y; 
    }
        since this fn does not read data from state variable, smart contract or blockchain, therefore this is a pure fn

## Counter using solidity

    int public count = 0;
    since uint doesn't support negative values, so if we try decrement first once contract is deployed it gives error. so make count as int.

    function increment() external {
        count += 1;
    }
    function decrement() external {
        count -= 1;
    }
    since these fns modify the value of count it is not a read fn, therefore it has no view or pure 

## Default values
    
    State and local variables in solidity have default values

    bool public b; (false)
    uint public u; (0)
    int public i; (0)
    address public addr; (0x0000000000000000000000000000000000000000)
        zero address, sequence of 40 zero's followed after 0x
    bytes32 public b32; (0x0000000000000000000000000000000000000000000000000000000000000000)
        32 byte hexadecimal representation of 0's, sequence of 64 zero's followed after 0x
    
    mapping, structs, enums, fixed sized array ...

## Constants

    If a State variables value never change then its better to declare it as a constant.
    By declaring a state variable as constant, we can save gas when a function is called that uses
    that state variable.

    contract Constants {
        address public constant MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;
            21442 gas 
        Keyword constant, variable name in all caps as its a coding convention

        uint public constant MY_UINT = 123;
            21371 gas
    }

    contract Var {
        address public MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; 
            23575 gas
        uint public MY_UINT = 123;
            23471 gas
    }

## If Else

    function num(uint _x) external pure returns(uint){
        if (_x ==1 ) {
            return 1;
        }
        else if (_x == 2) {
            return 2;
        }
        return 3;  
    }

    function ternary(uint _x) external pure returns(bool){
        return _x % 2 ==0 ? true : false;
    }

## For loops
Bigger the number of iterations in a loop, more the gas costs
    function loops() external pure {
        for(uint i = 0; i < 10; i++) {
            
            <-- code -->
            
            To skip certain iteration of the code use continue\
            if (i == 3) {
                continue;
                continue means continue with the next iteration of for loop ie i = 4's iteration
            }

            <-- more code --> (this part will not be executed when i = 3)
            
            To exit the for loop in-between (we'll finish the loop when i = 5)
            if (i == 5) {
                break;
            }
        }
    }

## While loops

    while (condition) {
        // code runs forever until condition becomes false
    }

## For and While loops for sum of n numbers

    function sumFor(uint _n) external pure returns(uint) {
        uint sum;
        for (uint i = 1; i <= _n; i++) {
            sum += i;
        }
        return sum;        
    }

    function sumWhile(uint _n) external pure returns(uint) {
        uint sum;
        while (_n != 0) {
            sum = sum + _n;
            _n--;
        }
        return sum;       
    }

## Error

    when we call a fn in a contract there are 3 ways to throw an error require, revert, assert.
    When an error is thrown inside a transaction the gas is refunded, state variables which are updated, will be reverted.
    In solidity 0.8.4 we can use custom error to save gas.

## Require
    Require is used to validate input and access control - controlling who gets to call the fn.
        require(cond, "if not print this") - input validation; checks condition, if false throws error msg.


    function require(uint256 _i) public pure {
        require(_i <= 10, "i > 10");
            we require input i to be less than or equal to 10.

        // more code if cond passes       
    }

## Revert 

    function revert(uint256 _i) public pure {
        if (_i > 10) {
            revert("i > 10");
        }
    }

    revert is better option if your condition to check is nested in a lot of if statements
        if (_i > 1) {
            // code
            if(_i > 2) {
                // more code
                if (_i > 10) {
                revert("i > 10"); 
                }
            }
        }

## Assert

    Assert is used to check for conditions that should always be true. If condition evaluates to false then it means there might be
    a bug in the smart contract

    uint256 public num = 123;
    function assert() public view {
        assert(num == 123); // if not then there is a bug in contract
    }

    Now if we call assert() after foo() then assert will no longer be true
    function foo() public {
        // accidently update num
        num = 456;
    }

## Gas refund

    If we send 1000 gas and it used up 100 gas then there will be a gas refund of 900 gas

## State variables reverted
    Any state variables updated before the error was thrown will be undone 

    function foo(uint256 _i) public {
        num += 1;
        require(_i < 10);
    }
    If we pass 13 then the state variable will be updated and since 13 > 10 the check fails; so whatever update was made to the state variable
    num will be undone

## Custom errors

    Custom error is cheaper than to use than using require with some error msg - longer the error msg the more gas it uses.
    Right now custom errors can only be used with revert so we need to transform any code with require to revert custom error.
    
    Declaring custom error - error <name of custom error>

    error MyError();
    function customError(uint256 _i) public pure {
        if (_i > 10) {
            revert MyError();
        }
    }

Logging data inside custom error

    error MyError(address caller, uint256 i); - we log the caller of the function and the input that was passed in.  
    function customError(uint256 _i) public view { - since msg.sender is not a local but a global variable so change the function to view type
        if (_i > 10) {
            revert MyError(msg.sender, _i); - This error msg logs details of sender address and data passed into the error
        }
    }

## Function modifier - allows to reuse code before and / or after function

    modifier <name of fn modifier> {
        // condition
        _; - underscore tells solidity to call the actual fn that this fn modifier wraps. ie execute the rest of the code of the fn. ie call the main fn 
    }
    After this, declare the fn modifier inside the fn signature to which the modifier is to be added.

Basic example 

without modifier
    bool public paused;
    uint256 public count;

    function setPause(bool _paused) external {
        paused = _paused;
    }

    function inc() external {
        require(!paused, "paused");
        count += 1;
    }

    function dec() external {
        require(!paused, "paused");
        count -= 1;
    }

    The functions inc() and dec() can be called only if the condition is met ie the contract is not paused.  
    
    Here the require statement is repeated in multiple functions. So we create a fn modifier for the require statement requiring that the 
    fn can only be called if the contract is not paused.

With modifier

    modifier whenNotPaused() {
        require(!paused, "paused");
        _;
    }

    function inc() external whenNotPaused {
        count += 1;
    }

    function dec() external whenNotPaused {
        count -= 1;
    }

Example of passing inputs to fn modifier

without modifier
    function incBy(uint256 _i) external whenNotPaused { 
        require(_i <= 100, "i >100"); 
        count += _i;
    } - count is incremented by a specific value only if it is less than 100

with modifier
    modifier cap(uint256 _i) { - variable name can be same cause its scope is this modifier fn onlyz
        require(_i <= 100, "i >100");
        _;
    }

    function incBy(uint256 _i) external whenNotPaused cap(_i) { - variable name to be passed to modifier should be same as the variable name the fn receives as input
        count += _i;
    }

## Sandwich
    fn modifier that sandwiches a fn, means some code will be executed inside the fn modifier, the actual fn will be called and 
    afterwards it will execute more code inside the fn modifier. Also we can add more checks in between these codes.

    modifier sandwich() {
        // code - 1. executes some code
        count += 5;
        _; // calls the main fn
        // more code - executes more code afterwards
        count *= 3;
    }

    function foo() external sandwich {
        count += 1;
    }

    When fn foo is called it first executes the fn modifier sandwich, so it updates count by 5. Then call the main fn which it is attached to
    in this case its foo() so it updates the count by 1 [now count = 6]. After foo() is done executing control is gonna execute more code in the
    fn modifier sandwich, so count is multiplied by 2 [now count = 12].

## Modifier Example
        contract Modifier {

            bool public paused;
            uint256 public count;
            uint public value;
            uint public newValue;

            function pause(bool _paused) external {
                paused = _paused;
            }

            modifier isPause() {
                assert(paused);
                _;
            }
            modifier counter(uint _count) {
                require(_count % 2 == 0, "Invalid count");
                _;
            }

            modifier foo() {
                value = count;
                _;
                newValue = count;
            }

            function fn(uint _count) external isPause counter(_count) foo {
                count = _count;
            }
        }

## Constructor 
    Constructors are special fns that can be called only once when the contract is deployed whereas normal fns can be called multiple times, 
    constructors are mainly used to initialize state variables.
    Parameters are passed during deployment [In remix parameters to constructors are passed via with deploy option]

    address public owner;
    uint public x;

    constructor(uint _x) {
        x = _x; - write code like regular fn
        owner = msg.sender; - initializing the state variable owner to the account that deployed this contract.
                              msg.sender will be the address that deployed this contract
    } 

## Ownable 
    
    Application to claim ownership of the contract

    This contract will have a owner[who deploys this contract], only the owner will be able to set a new owner and there are certain fns only 
    the owner can call.

contract Ownable {
    address public owner; - Declaring global variable owner

    constructor() { - Initializing the owner to the caller who deployed this contract
        owner = msg.sender;
    }

    Creating a Fn modifier for a fn to set a new owner, that can be called only by the owner

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function setOwner(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid address [0x0000...]");
        owner = _newOwner;
    }

    function onlyOwnerCanCall() external onlyOwner {
        // code
    }

    function anyOneCanCall() external {
        // code
    }
}

## Function Outputs - multiple named Outputs

    function returnMultipleOutputs() public pure returns(uint, bool) {
        return(1, true);
    }
    public cause we can use this fn in other fns inside this contract. returns(return types 1, return type 2) inside the body we match the 
    return type.

    Here we know the return type, but we dont know what they represent so name the outputs [similar to naming variable].
    function named() public pure returns(uint x, bool b) {
        return(1, true);
    }
    This tells solidity that we want to copy the returned value into variables x and b;
    so nameing return type tells solidity where to copy/put these return values.

    when we have a named output we can implicitly return values, so the return statement can be ommitted. Just simply assign the value to the 
    named outputs inside the fn body - This will save little gas as there is 1 less copy to do

    function assigned() public pure returns(uint x, bool b) {
        x = 1;
        b = true;
    }

## Destructuring assignment
    To capture the output in another fn

    function returnMany() public pure returns (uint256, bool) {
        return (1, true);
    }

    We capture this fns output in another fn

    function destructuringAssignments() public pure {
        (uint x, bool b) = returnMany(); - Inside destructuringAssignments() we call returnMany() which returns a uint and bool.
        (, bool _b) = returnMany(); - To avoid name conflicts use _b
    }

    To capture multiple outputs and assign variables to it inside destructuringAssignments(), we start with paranthesis declaring the datatypes 
    and name of the variables to be captured inside a () [(uint x, bool b)] and assign this to the fn returnMany().

    If we need just one output out of many outputs then we ommit the unwanted variables, but keep the comma
    function destructuringAssignments() public pure {
        (, bool b) = returnMany(); 
    }

## Array

    Arrays in solidity can be dynamic or fixed size
        - Initialization
        - Insert (push), get, update, delete, pop, length 
        - Creating array in memory 
        - Returning array from fn

    Initialization 
        Initializing a dynamic[variable size] array as a state variable
            uint[] public nums = [1,2,3];
        Fixed size array
            uint[5] public numsFixed = [4, 5, 6, 7, 8];

    Operations - Insert (push), get, update, delete, pop, length
    function examples() external {
        nums.push(4);
            Insert 4 to the end of nums array state variable => [1, 2, 3, 4]

        uint x = nums[1];
            Access array elements with index

        nums[2] = 777; - [1, 2, 777, 4]
            Update an element in the array

        delete nums[1]; 
            Delete an element from the array - even after deletion length of the array remains same. 
            This will delete the element at index 1 and set it to the default value 0 => [1, 0, 777, 4]

        nums.pop(); - [1, 0, 777]
            Pop - to shrink size of array - remove last element from the array

        uint len = nums.length;
            Length of the array
        
        create array in memory - only update or get operations are possible
        
        uint256[] memory arr = new uint256[](5);
            array in memory are of fixed size so push an pop operations wont work
        arr[1] = 123; - update
    }

    Returning array from fn
        Not recommended for the same reason as to keep the for loops small, the bigger the array, the more gas it will use 
        [For executing bigger arrays more gas will be consumed and there will not be any left to execute the return array function]

    function returnArray() external view returns (uint256[] memory) {
        return nums;
    }
    memory - tells solidity that we want to copy the state variables nums into memory then return it

## Remove an element from the array by shifting

    Deleting an elt from an array doesnt actually remove the element, it just resets it to its default value
        function example() public {
            array = [1, 2, 3];
            delete array[1]; // [1, 0, 3]
        }

    Remove an element from the array and shrink its length by shifting 
        Shift all elts to the left then pop the last element
            [1, 2, 3] -- remove(1) -> [1, 3, 3] --> [1,3]
            [1, 2, 3, 4, 5, 6] -- remove(2) --> [1, 2, 4, 5, 6, 6] --> [1, 2, 4, 5, 6]

        we copied elts from right to left - starting at the element one right to the one that we want to remove and after we're done copying 
        each elt we remove the last elt
            edge case - [1] -- remove(0) --> [1] --> []

        
    function remove(uint256 _index) public {
        require(_index < array.length, "index out of bound"); 
            check index < array length
            
        copy elts from right to left starting from the index to remove
        for (uint256 i = _index; i < array.length - 1; i++) {
            We're iterating till array.length - 1, cause once we shifted the last elt to 2nd last position, we need to pop last element.
            array[i] = array[i + 1];
                we'll have an array that has elts from right shifted to left starting form the index position of the elt to be removed
        } 
        array.pop();
            Pop the last/duplicate element
    }

    When fn test() is called the array is initialized [The scope of this array is not local to this fn cause its declaration is done outside the fn so 
    its a state variable]

    function test() external { 
        array = [1, 2, 3, 4, 5]; 
        remove(2); - Since the remove fn is public we can access it from inside other fns in the smart contract 
                   - external - to access the fn once contract is deployed
                   - public - to access the fn from other fns etc in the smart contract
        => [1, 2, 4, 5]
        assert(array[0] == 1);
        assert(array[1] == 2);
        assert(array[2] == 4);
        assert(array[3] == 5);
        assert(array.length == 4);
    }
}

## Array Remove An Element By Replacing Last
    Replace the element you want to remove with the last element and remove the last element. 

    [1, 2, 3, 4] -- remove(1) --> [1, 4, 3]
    [1, 4, 3] -- remove(2) --> [1, 4]

    More gas efficient than Array shifting; but here the order of array is not preserved.
    This method doesnt shift array elts. Just requires 2 operations replacing the elt to remove and removing the last elt(so we are not 
    shifting we are shuffling around the array elts)

    uint[] public arr;
    function replaceLast(uint _index) public {
            arr[_index] = arr[arr.length - 1];
            arr.pop();
    }

    function test() external {
        arr = [1, 2, 3, 4, 5]; // [1, 2, 4, 5]
        replaceLast(1);
        assert(arr[0] == 1);
        assert(arr[1] == 5);
        assert(arr[2] == 3);
        assert(arr[3] == 4);
        assert(arr.length == 4);
        arr = [1];
        replaceLast(0);
        assert(arr.length == 0);
    }
}

## Mapping 
    like a dictionary in python - it allows for efficient lookup
        To find David is present in the array ["alice", "bob", "charlie"] 
        normally - iterate each element and see if its equal to David
        mapping - ["alice: true", "bob: true", "charlie: true"] we can find with just one lookup
        In this mapping we know alice is present, bob is present, charlie is present, but David is not

# simple mapping - mapping(key_type => value_type) visiblity_modifier mapping_name;

        mapping(address => uint256) public balances; 
            This mapping represent balance of each address.
        So if we are given a address we can lookup the balance of it using the mapping balance. 

    Set value in a mapping

        function examples() external {
            To set a key to a certain value in a mapping using balances
            To set a key(address) to a certain value (account balance) in mapping balances

            balances[msg.sender] = 123;
                This maps the address msg.sender(ie key) to a balance 123(ie value)

    Get value stored in a mapping - Syntax is similar to how we access an array

            To get balance of msg.sender stored in balances
                uint bal = balances[msg.sender];
                    balances[msg.sender] gets the balance of the account msg.sender form the mapping and stores it to bal

            We can also get balances of mapping that we havent set yet.
                uint256 bal2 = balances[address(1)]; - 0 default value of uint. 
                    we are able to access the value stored in balalnces of address(1)

    Update a mapping
            balances[msg.sender] = 456;
            balances[msg.sender] += 456; // 123 + 456 = 579

    Delete - clear value stored in mapping - delete <place you want to delete>  - value will be reset
            delete balances[msg.sender]; - 0 default value of uint
            
        }

# Nested mapping

        mapping(address => mapping(address => bool)) public isFriend; 
            This mapping represent whether an address is a friend with another address
    
        function examples() external {

    Set msg.sender is a friend of this contract
            isFriend[msg.sender][address(this)] = true;

            This maps msg.sender to address(this) which maps to true therby saying msg.sender is a friend of addrss(this)
        }

## Iterable mapping
    In array we can get size of array and iterate through each element using for loop; but we cannot do these in mapping; 
    unless we internally keep track of all the keys in the mapping.

# Build an iteratable mapping - we store each key into array

    mapping(address => uint) public balances; - Mapping that represent balance of an address

    To keep track of size of mapping and get all elts we need to add new data

    While adding new data to balances mapping we need to keep track keys(addresses) and check whether the key is already 
    inserted or not, the key for the balances mapping is address.
    
    mapping(address => bool) public inserted; - The inserted mapping uses the (address) key of balances mapping as its key to store a bool value.
        So if a key(address) maps to true, it means that address is already present in the balances mapping.

        when we insert new data into the balances mapping, inside the inserted mappping we'll set the address that we 
        just inserted into the balances mapping to true

    we also need to keep track of all of the keys that we inserted into an array, since the key type is address so 
    we'll create an array of addresses

    address[] public keys;

First fn is to set the balance of the mapping balances

    function set(address _key, uint _val) external {
        
        first thing is to update the balance mapping

        balances[_key] = _val; - eg: balances[msg.sender] = 123;

Next keep track of this key and check whether it is newly inserted or not
    If newly inserted we'll append to the array of keys - so we'll have an array of keys(addresses) which we can use to 
    get all of the values stored in the balances mapping

        if (!inserted[_key]) {
            inserted[_key] = true;
            keys.push(_key);
                If the _key is not in the inserted mapping, then insert the key to it and push the inserted _key to the 
                key array
        }
    } - This fn helps us get the size of the mapping and iterate through all of the keys in the mapping. So we'll be able 
        to get all the values stored in the mapping balances.

Get the size of the balances mapping

    function getSize() external view returns (uint size) {
         size = keys.length;
    }

Get all the value of the balances mapping using for loop

    function first() external view returns(uint){
        return balances[keys[0]]; 
            Keys[0] will return the first address that was inserted [also stored in keys array]. 
            Using it we can get the value that was stored in the balances. 
    }

    function last() external view returns (uint) { 
        return balances[keys[keys.length - 1]];
    }

    function value(uint _i) external view returns(uint) {
        return balances[keys[_i]];
    }

            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.4;

            contract IterableMapping {
                mapping (address => uint) public balances;
                mapping (address => bool) public inserted;

                address[] public keys;

                function addValues(address _key, uint _val) external {
                    balances[_key] = _val;

                    if (!inserted[_key]) {
                        inserted[_key] = true;
                        keys.push(_key);
                    } 
                }

                function first() external view returns (uint) {
                    return balances[keys[0]];
                }

                function last() external view returns (uint) {
                    return balances[keys[keys.length - 1]];
                }

                function value(uint _i) external view returns (uint) {
                    return balances[keys[_i]];
                }
            }

## Structure - struct
    Structs allows to group data together - collection of different types combined together to create a new type.
        - creating a structure
        - Declaring a structure variable
        - Initializing structure members

creating a structure
    struct Car {
        string model;
        uint year;
        address owner;
    }

Declaring a structure variable - since after initializing we still need access to the data in the structure
    
    we can use struct as a state variable
        Car public car;

    we can also create an array of struct
        Car[] public cars; [uint[] - integer array , since Car is struct therfore Car[] is structure array]

    we can define a mapping from the owner to cars
        mapping (address => Car[]) public carsByOwner;

Initializing structure members - 3 ways

    function examples() external { 
        1. Simiilar to how we would execute a fn - we put all the parameters into paranthesis - order matters

            Car memory toyota = Car("Toyota", 1990, msg.sender); 
                creating a variable of type struct car (Car) inside memory so this Car variable will only exist when this 
                fn is called

        2. By passing key value pairs inside the paranthesis - order doesnt matter
            Car memory lambo = Car({model: "Lamborghini", year: 1980, owner: msg.sender}); 

        3. Just define and the struct will have a default value cause variables in solidity hava a default value

            Car memory tesla; - model - empty string, year - 0, owner - address(0)
        adding data
            tesla.model = "Tesla";
            tesla.year = 2010;
            tesla.owner = msg.sender;

    When we call this fn it'll initialize the struct in memory so the fn will execute and after execution these structs 
    will be gone

    # To get structs from the smart contract after execution put these in a state variables 

        - we'll push these structs into the cars array  - array of structure [or we can create individual struct state var 
        for all these struct]  
            cars.push(toyota);
            cars.push(lambo);
            cars.push(tesla);
                Once this part is executed our struct will be stored in the cars array - we don't really need to 
                initialize a struct as memory and then save it into a state variable, we can do it in one single line

            - Create a struct and push it immediately into the array
            cars.push(Car("Ferrari", 2020, msg.sender)); 
                equivalent to initializing a car in memory and then pushing it to the cars array

        - adding to state variable car
            car = Car("BMW", 1970, msg.sender);
                Once this part is executed our struct will be stored in the car variable
    }

# Once data is stored in a state variable we can access it and update it.

# Access

- If stored in a state variable we can directly access it if its public.

- If stored in an array we need to access it via the index number - 

    Cars memory _car = cars[0]; - since we just need the car from the state variable and read it, and no 
                                  modification, then we can decalare as memory
        Now _car is a struct that stores the details of the structure in the index 0 of the cars array

    To access the struct members of _car
        _car.model; 
        _car.year;
        _car.owner;

# update
    To modify the year of the car - first thing is to change the keyword memory to storage since memory means we are 
    loading this data(_car) onto memory, so if we modify anything on memory then once the fn is done executing nothing 
    will change whereas storage means we want to update the variables stored inside the smart contract.

        Car storage _car = cars[0];
        _car.year = 1985;
            This will update the car stored in the cars arrays first element and update the year to 1985 
            Once this fn is done executing this change will be saved.

    We can also use the keyword delete to reset the field stored in a struct
        delete _car.owner;
            This will reset the owner of the car to the default value ie address(0)

    we can also call delete on a struct to reset all the data stored in a struct
        delete cars[1];
            This will delete the cars struct that is stored in the cars array the first elt, meaning that whatever is 
            stored inside cars[1] will be reset to default value.
            After this Car struct stored here (cars[1]) will have a empty string, year will be 0, owner 0 address

contract Structs {
    struct Car {
        string model;
        uint year;
        address owner;
    }

    Car public car;
    Car[] public cars;

    function set() external {
        car = Car("BMW", 1970, msg.sender);

        Car memory toyata = Car("Toyata", 1980, msg.sender);
        Car memory lambo = Car({model : "Lambo", year : 1990, owner : msg.sender});
        Car memory tesla;
        tesla.model = "Tesla";
        tesla.year = 2000;
        tesla.owner = msg.sender;

        cars.push(toyata);
        cars.push(lambo);
        cars.push(tesla);       

        cars.push(Car("ferari", 2010, msg.sender)); 
    } 
    function get() external {
        Car memory _car = cars[0];
        _car.model; 
        _car.year;
        _car.owner;
    }

    OR
            function get() external view returns(string memory, uint, address) {
                Car memory _car = cars[0];
                return(_car.model, _car.year, _car.owner);
            }

    function update() external {
        Car storage _car = cars[0];
        _car.year = 1985;

        delete _car.owner;

        delete cars[1];
    }
}

## Enum
    Structs allow us to express multiple choices eg bool - true and false. 
    If we need to express more choices then use Enum

    contract Enum {
    enum Status {
        None,
        Pending,
        Shipped,
        Completed,
        Rejected,
        Canceled
    } - indexed from 0

    Status public status; - Using enum as state variable

    function set(Status _status) external { - Taking enum as input and setting the status to the enum from input
        status = _status;
    }

    function setSpecific() external { - update enum to a specific enum
        status = Status.Pending;
    }

    function get() external view returns(Status) { - returning enum from a fn
        return status;
    }

    function reset() external { - Reset enum to default value using delete
        delete status;
            This will reset the status state variable which is a enum to its default value ie the first item defined inside the enum
    }
}

eg of combining enums with other datatypes

    Using inside a struct
        struct Order {
            address buyer;
            Status status; - status will be the enum status that we defined
        }

    Array of Order / array of struct
        Order[] public orders;


## Data Locations - storage, memory and calldata
    When we use dynamic datatype as a variable we need to declare its data location.
        
        Storage - variable is state variable 
        memory - data is loaded onto memory 
        calldata - like memory, but can be used only for fn inputs 
            
        Storage to update data and memory to read data

# Storage 
    All the variables and arrays declared outside of the function are state variables and stored in Storage by default.
    We can also declare a variable of storage type inside the function by using the keyword storage. 
    Storage means data is stored directly on Blockchain. - use wisely or can be expensive

    Use storage when you want to make an instance of a variable that your smart contract will "save" in its bytcode 
    (I.e for changes that need to persist between transactions, like balances)

    struct MyStruct {
        uint foo;
        string text;
    }

    mapping (address => MyStruct) public myStructs;

    function insert() external {
        myStructs[msg.sender] = MyStruct({foo : 123, text : "bar"});

    To modify a struct first thing is to declare it as storage - Only if we need to read it use memory
    Here we're telling solidity that the variable we're gonna use should point back to the storage, meaning
    the state variable
        MyStruct storage myStruct = myStructs[msg.sender];

            To modify a struct firstly access it in a variable,here its myStruct.

            Since structure is mapped from an address, to access the struct of a specific address use the key (myStructs[msg.sender]),
            Now since this address/key points to its corresponding struct MyStruct, we can access the key's structure elements 
            via the myStruct variable.

        myStruct.foo = 456; - This change is saved


        MyStruct memory readOnly = myStructs[msg.sender];

        This will build MyStruct stored at msg.sender to memory. We can also modify the variable but
        since data is loaded into memory, after fn execution this change will not be saved.

        readOnly.foo =456; - This change is not saved

# memory
    Variables created in a function are by default memory.

    
    When writing fn both for input and output/return we'll use memory and calldata. eg we can pass an uint[] as input, 
    then we need to declare the data location. Likewise we can also return a dynamic data type, in that case we want to 
    declare the return type as memory

    Returning structure from memory

    function insert(uint[] memory y, string memory s) external returns (MyStruct memory){

        myStructs[msg.sender] = MyStruct({foo : 123, text : "bar"});
        MyStruct memory readOnly = myStructs[msg.sender]; 
        readOnly.foo =456;

        return readOnly;
    }

    Returning an uint array - For eg we'll inititalize an uint[] in memory and return it 

    function insert(uint[] memory y, string memory s) external returns (MyStruct memory){
        uint[] memory memArray = new array[](5); - This array will be loaded into memory so only fixed size is possible
        memArray[0] = 234;
        return memArray
    } 

# calldata - its like memory, except that its used for fn inputs since it has a potential to save gas
    Datatype declared as calldata are non modifiable - means we cannot change the values inside it , it can save gas when 
    you pass this input into another fn

    function insert(uint[] calldata y, string calldata s) external returns (uint[] memory){

        _internal(y);

    }

    function internal(uint[] calldata y) private {
        This fn takes the uint[] array from the input of insert() fn [uint[] calldata y], and pass it to the fn _internal(y)

        The difference between loading the input to memory and calldata 
        If the input of this fn was declared as memory, then solidity would take the input[of insert() fn [uint[] calldata y]]
        and when it passes it to the fn [_internal(y)], then its gonna copy each element in the uint[] array[of insert()]
        so it'll be creating a new uint[] array inside the memory then pass it onto the input of this fn(internal(uint[] calldata y))

        If we declare it as calldata then there is one less copying to do, ie it takes y from the input [from insert()] and 
        then passes it to the internal() without copying it, hence saves gas 

    }

use storage to load dynamic data that you'll update
use memory to read the data or modify it without saving it to the blockchain 
for fn inputs use calldata to save gas, whenever the calldata input is passed to another fn it saves gas by avoiding copies    





